{"version":3,"file":"offline-support.js","mappings":"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","sources":["webpack://vuln-bot/./src/assets/ts/offline-support.ts"],"sourcesContent":["/**\n * Offline support and service worker registration\n */\n\ninterface ServiceWorkerStatus {\n  supported: boolean;\n  registered: boolean;\n  offline: boolean;\n  updating: boolean;\n}\n\nexport class OfflineSupport {\n  private status: ServiceWorkerStatus = {\n    supported: \"serviceWorker\" in navigator,\n    registered: false,\n    offline: !navigator.onLine,\n    updating: false,\n  };\n\n  private listeners: Map<string, Function[]> = new Map();\n\n  constructor() {\n    this.init();\n  }\n\n  private init(): void {\n    if (!this.status.supported) {\n      console.warn(\"Service Worker not supported\");\n      return;\n    }\n\n    this.registerServiceWorker();\n    this.setupOnlineOfflineListeners();\n    this.setupVisibilityChangeListener();\n  }\n\n  private async registerServiceWorker(): Promise<void> {\n    try {\n      const registration = await navigator.serviceWorker.register(\n        \"/vuln-bot/assets/js/service-worker.js\",\n        {\n          scope: \"/vuln-bot/\",\n        }\n      );\n\n      console.log(\"Service Worker registered successfully\");\n      this.status.registered = true;\n      this.emit(\"registered\", registration);\n\n      // Listen for service worker updates\n      registration.addEventListener(\"updatefound\", () => {\n        this.status.updating = true;\n        this.emit(\"updatefound\");\n\n        const newWorker = registration.installing;\n        if (newWorker) {\n          newWorker.addEventListener(\"statechange\", () => {\n            if (newWorker.state === \"installed\" && navigator.serviceWorker.controller) {\n              this.status.updating = false;\n              this.emit(\"updateready\");\n            }\n          });\n        }\n      });\n\n      // Listen for service worker messages\n      navigator.serviceWorker.addEventListener(\"message\", (event) => {\n        this.handleServiceWorkerMessage(event.data);\n      });\n\n      // Register for background sync (if supported)\n      if (\"sync\" in registration) {\n        this.setupBackgroundSync(registration);\n      }\n    } catch (error) {\n      console.error(\"Service Worker registration failed:\", error);\n      this.emit(\"error\", error);\n    }\n  }\n\n  private setupOnlineOfflineListeners(): void {\n    window.addEventListener(\"online\", () => {\n      this.status.offline = false;\n      this.emit(\"online\");\n      this.syncWhenOnline();\n    });\n\n    window.addEventListener(\"offline\", () => {\n      this.status.offline = true;\n      this.emit(\"offline\");\n    });\n  }\n\n  private setupVisibilityChangeListener(): void {\n    document.addEventListener(\"visibilitychange\", () => {\n      if (!document.hidden && navigator.onLine) {\n        this.syncWhenOnline();\n      }\n    });\n  }\n\n  private async setupBackgroundSync(registration: ServiceWorkerRegistration): Promise<void> {\n    try {\n      // Background sync is experimental and requires type assertion\n      await (\n        registration as ServiceWorkerRegistration & {\n          sync: { register: (tag: string) => Promise<void> };\n        }\n      ).sync.register(\"background-sync-vulns\");\n      console.log(\"Background sync registered\");\n    } catch {\n      console.log(\"Background sync not supported or failed to register\");\n    }\n  }\n\n  private handleServiceWorkerMessage(data: { type: string; message?: string }): void {\n    switch (data.type) {\n      case \"DATA_UPDATED\":\n        this.emit(\"data-updated\", data.message);\n        break;\n      default:\n        console.log(\"Unhandled service worker message:\", data);\n    }\n  }\n\n  private async syncWhenOnline(): Promise<void> {\n    if (!navigator.onLine || !this.status.registered) return;\n\n    try {\n      // Trigger background sync if available\n      const registration = await navigator.serviceWorker.ready;\n      if (\"sync\" in registration) {\n        // Background sync is experimental and requires type assertion\n        await (\n          registration as ServiceWorkerRegistration & {\n            sync: { register: (tag: string) => Promise<void> };\n          }\n        ).sync.register(\"background-sync-vulns\");\n      }\n    } catch (error) {\n      console.log(\"Background sync trigger failed:\", error);\n    }\n  }\n\n  public getStatus(): ServiceWorkerStatus {\n    return { ...this.status };\n  }\n\n  public isOffline(): boolean {\n    return this.status.offline;\n  }\n\n  public isSupported(): boolean {\n    return this.status.supported;\n  }\n\n  public async updateServiceWorker(): Promise<void> {\n    if (!this.status.registered) return;\n\n    try {\n      const registration = await navigator.serviceWorker.ready;\n      await registration.update();\n      this.emit(\"update-triggered\");\n    } catch (error) {\n      console.error(\"Service worker update failed:\", error);\n      this.emit(\"error\", error);\n    }\n  }\n\n  public async skipWaiting(): Promise<void> {\n    const registration = await navigator.serviceWorker.ready;\n    if (registration.waiting) {\n      registration.waiting.postMessage({ type: \"SKIP_WAITING\" });\n    }\n  }\n\n  // Event system\n  public on(event: string, callback: Function): void {\n    if (!this.listeners.has(event)) {\n      this.listeners.set(event, []);\n    }\n    this.listeners.get(event)!.push(callback);\n  }\n\n  public off(event: string, callback: Function): void {\n    const callbacks = this.listeners.get(event);\n    if (callbacks) {\n      const index = callbacks.indexOf(callback);\n      if (index > -1) {\n        callbacks.splice(index, 1);\n      }\n    }\n  }\n\n  private emit(event: string, data?: unknown): void {\n    const callbacks = this.listeners.get(event);\n    if (callbacks) {\n      callbacks.forEach((callback) => callback(data));\n    }\n  }\n}\n\n/**\n * Offline indicator component\n */\nexport class OfflineIndicator {\n  private element: HTMLElement | null = null;\n  private offlineSupport: OfflineSupport;\n\n  constructor(offlineSupport: OfflineSupport) {\n    this.offlineSupport = offlineSupport;\n    this.createIndicator();\n    this.setupEventListeners();\n  }\n\n  private createIndicator(): void {\n    this.element = document.createElement(\"div\");\n    this.element.id = \"offline-indicator\";\n    this.element.className = \"offline-indicator\";\n    this.element.setAttribute(\"role\", \"status\");\n    this.element.setAttribute(\"aria-live\", \"polite\");\n    this.element.style.cssText = `\n      position: fixed;\n      top: 0;\n      left: 0;\n      right: 0;\n      background: #dc2626;\n      color: white;\n      text-align: center;\n      padding: 8px;\n      font-size: 14px;\n      transform: translateY(-100%);\n      transition: transform 0.3s ease;\n      z-index: 9999;\n    `;\n\n    document.body.appendChild(this.element);\n  }\n\n  private setupEventListeners(): void {\n    this.offlineSupport.on(\"offline\", () => {\n      this.show(\"You are currently offline. Some features may be limited.\");\n    });\n\n    this.offlineSupport.on(\"online\", () => {\n      this.show(\"Connection restored. Syncing data...\", \"success\");\n      setTimeout(() => this.hide(), 3000);\n    });\n\n    this.offlineSupport.on(\"data-updated\", (message: string) => {\n      this.show(message, \"info\");\n      setTimeout(() => this.hide(), 3000);\n    });\n\n    this.offlineSupport.on(\"updateready\", () => {\n      this.show(\"New version available. Refresh to update.\", \"warning\");\n    });\n  }\n\n  private show(message: string, type: \"error\" | \"success\" | \"info\" | \"warning\" = \"error\"): void {\n    if (!this.element) return;\n\n    const colors = {\n      error: \"#dc2626\",\n      success: \"#10b981\",\n      info: \"#2563eb\",\n      warning: \"#f59e0b\",\n    };\n\n    this.element.textContent = message;\n    this.element.style.backgroundColor = colors[type];\n    this.element.style.transform = \"translateY(0)\";\n  }\n\n  private hide(): void {\n    if (!this.element) return;\n    this.element.style.transform = \"translateY(-100%)\";\n  }\n}\n\n/**\n * Cache management utilities\n */\nexport class CacheManager {\n  static async getCacheSize(): Promise<number> {\n    if (!(\"caches\" in window)) return 0;\n\n    let totalSize = 0;\n    const cacheNames = await caches.keys();\n\n    for (const name of cacheNames) {\n      const cache = await caches.open(name);\n      const keys = await cache.keys();\n\n      for (const request of keys) {\n        const response = await cache.match(request);\n        if (response) {\n          const blob = await response.blob();\n          totalSize += blob.size;\n        }\n      }\n    }\n\n    return totalSize;\n  }\n\n  static async clearCache(): Promise<void> {\n    if (!(\"caches\" in window)) return;\n\n    const cacheNames = await caches.keys();\n    await Promise.all(cacheNames.map((name) => caches.delete(name)));\n  }\n\n  static formatBytes(bytes: number): string {\n    if (bytes === 0) return \"0 Bytes\";\n\n    const k = 1024;\n    const sizes = [\"Bytes\", \"KB\", \"MB\", \"GB\"];\n    const i = Math.floor(Math.log(bytes) / Math.log(k));\n\n    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + \" \" + sizes[i];\n  }\n}\n\n// Initialize offline support when DOM is ready\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n  const offlineSupport = new OfflineSupport();\n  new OfflineIndicator(offlineSupport);\n\n  // Export for global access - debugging only\n  (window as unknown as { offlineSupport: OfflineSupport }).offlineSupport = offlineSupport;\n  (window as unknown as { cacheManager: typeof CacheManager }).cacheManager = CacheManager;\n});\n\nexport { OfflineSupport as default };\n"],"names":["OfflineSupport","constructor","status","supported","navigator","registered","offline","onLine","updating","listeners","Map","this","init","registerServiceWorker","setupOnlineOfflineListeners","setupVisibilityChangeListener","console","warn","registration","serviceWorker","register","scope","log","emit","addEventListener","newWorker","installing","state","controller","event","handleServiceWorkerMessage","data","setupBackgroundSync","error","window","syncWhenOnline","document","hidden","sync","type","message","ready","getStatus","isOffline","isSupported","updateServiceWorker","update","skipWaiting","waiting","postMessage","on","callback","has","set","get","push","off","callbacks","index","indexOf","splice","forEach","OfflineIndicator","offlineSupport","element","createIndicator","setupEventListeners","createElement","id","className","setAttribute","style","cssText","body","appendChild","show","setTimeout","hide","textContent","backgroundColor","success","info","warning","transform","CacheManager","getCacheSize","totalSize","cacheNames","caches","keys","name","cache","open","request","response","match","blob","size","clearCache","Promise","all","map","delete","formatBytes","bytes","i","Math","floor","parseFloat","pow","toFixed","cacheManager"],"sourceRoot":""}