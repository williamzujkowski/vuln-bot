{"version":3,"file":"image-optimization.js","mappings":"mBAYO,MAAMA,EAIX,WAAAC,CAAYC,EAAkC,CAAC,GAHvC,KAAAC,SAAwC,KAI9CC,KAAKF,OAAS,CACZG,WAAYH,EAAOG,YAAc,OACjCC,UAAWJ,EAAOI,WAAa,GAC/BC,aAAcL,EAAOK,cAAgB,UACrCC,YAAaN,EAAOM,aAAe,SACnCC,WAAYP,EAAOO,YAAc,SAGnCL,KAAKM,MACP,CAEQ,IAAAA,GACA,yBAA0BC,QAMhCP,KAAKD,SAAW,IAAIS,qBACjBC,IACCA,EAAQC,QAASC,IACXA,EAAMC,iBACRZ,KAAKa,UAAUF,EAAMG,QACrBd,KAAKD,UAAUgB,UAAUJ,EAAMG,YAIrC,CACEb,WAAYD,KAAKF,OAAOG,WACxBC,UAAWF,KAAKF,OAAOI,YAI3BF,KAAKgB,iBAnBHhB,KAAKiB,eAoBT,CAEQ,aAAAD,GACSE,SAASC,iBAAiB,sCAClCT,QAASU,IACdpB,KAAKD,UAAUsB,QAAQD,IAE3B,CAEQ,SAAAP,CAAUO,GAChB,MAAME,EAAMF,EAAIG,QAAQD,KAAOF,EAAIE,IACnC,IAAKA,EAAK,OAEVF,EAAII,UAAUC,IAAIzB,KAAKF,OAAOK,cAG9B,MAAMuB,EAAc,IAAIC,MAExBD,EAAYE,OAAS,KACnBR,EAAIE,IAAMA,EACVF,EAAII,UAAUK,OAAO7B,KAAKF,OAAOK,cACjCiB,EAAII,UAAUC,IAAIzB,KAAKF,OAAOM,oBAGvBgB,EAAIG,QAAQD,KAGrBI,EAAYI,QAAU,KACpBV,EAAII,UAAUK,OAAO7B,KAAKF,OAAOK,cACjCiB,EAAII,UAAUC,IAAIzB,KAAKF,OAAOO,YAC9B0B,QAAQC,KAAK,yBAAyBV,MAGxCI,EAAYJ,IAAMA,CACpB,CAEQ,aAAAL,GACSC,SAASC,iBAAiB,iBAClCT,QAASU,IACdpB,KAAKa,UAAUO,IAEnB,CAEO,OAAAa,GACDjC,KAAKD,UACPC,KAAKgB,eAET,CAEO,OAAAkB,GACDlC,KAAKD,WACPC,KAAKD,SAASoC,aACdnC,KAAKD,SAAW,KAEpB,EAkGmD,IAAIqC,IA8CzDlB,SAASmB,iBAAiB,mBAAoB,KAC5C,MAAMC,EAAiB,IAAI1C,EAGV,IAAI2C,iBAAiB,KACpCD,EAAeL,YAGRZ,QAAQH,SAASsB,KAAM,CAC9BC,WAAW,EACXC,SAAS,K","sources":["webpack://vuln-bot/./src/assets/ts/image-optimization.ts"],"sourcesContent":["/**\n * Image optimization and lazy loading utilities\n */\n\ninterface ImageOptimizationConfig {\n  rootMargin?: string;\n  threshold?: number;\n  loadingClass?: string;\n  loadedClass?: string;\n  errorClass?: string;\n}\n\nexport class ImageOptimization {\n  private observer: IntersectionObserver | null = null;\n  private config: Required<ImageOptimizationConfig>;\n\n  constructor(config: ImageOptimizationConfig = {}) {\n    this.config = {\n      rootMargin: config.rootMargin ?? \"50px\",\n      threshold: config.threshold ?? 0.1,\n      loadingClass: config.loadingClass ?? \"loading\",\n      loadedClass: config.loadedClass ?? \"loaded\",\n      errorClass: config.errorClass ?? \"error\",\n    };\n\n    this.init();\n  }\n\n  private init(): void {\n    if (!(\"IntersectionObserver\" in window)) {\n      // Fallback for browsers without IntersectionObserver\n      this.loadAllImages();\n      return;\n    }\n\n    this.observer = new IntersectionObserver(\n      (entries) => {\n        entries.forEach((entry) => {\n          if (entry.isIntersecting) {\n            this.loadImage(entry.target as HTMLImageElement);\n            this.observer?.unobserve(entry.target);\n          }\n        });\n      },\n      {\n        rootMargin: this.config.rootMargin,\n        threshold: this.config.threshold,\n      }\n    );\n\n    this.observeImages();\n  }\n\n  private observeImages(): void {\n    const images = document.querySelectorAll('img[loading=\"lazy\"], img[data-src]');\n    images.forEach((img) => {\n      this.observer?.observe(img);\n    });\n  }\n\n  private loadImage(img: HTMLImageElement): void {\n    const src = img.dataset.src ?? img.src;\n    if (!src) return;\n\n    img.classList.add(this.config.loadingClass);\n\n    // Create a new image to preload\n    const imageLoader = new Image();\n\n    imageLoader.onload = () => {\n      img.src = src;\n      img.classList.remove(this.config.loadingClass);\n      img.classList.add(this.config.loadedClass);\n\n      // Remove data-src to prevent reloading\n      delete img.dataset.src;\n    };\n\n    imageLoader.onerror = () => {\n      img.classList.remove(this.config.loadingClass);\n      img.classList.add(this.config.errorClass);\n      console.warn(`Failed to load image: ${src}`);\n    };\n\n    imageLoader.src = src;\n  }\n\n  private loadAllImages(): void {\n    const images = document.querySelectorAll(\"img[data-src]\");\n    images.forEach((img) => {\n      this.loadImage(img as HTMLImageElement);\n    });\n  }\n\n  public refresh(): void {\n    if (this.observer) {\n      this.observeImages();\n    }\n  }\n\n  public destroy(): void {\n    if (this.observer) {\n      this.observer.disconnect();\n      this.observer = null;\n    }\n  }\n}\n\n/**\n * WebP support detection and image format optimization\n */\nexport class ImageFormatOptimizer {\n  private static webpSupported: boolean | null = null;\n\n  static async checkWebPSupport(): Promise<boolean> {\n    if (this.webpSupported !== null) {\n      return this.webpSupported;\n    }\n\n    return new Promise((resolve) => {\n      const webp = new Image();\n      webp.onload = webp.onerror = () => {\n        this.webpSupported = webp.height === 2;\n        resolve(this.webpSupported);\n      };\n      webp.src =\n        \"data:image/webp;base64,UklGRjoAAABXRUJQVlA4IC4AAACyAgCdASoCAAIALmk0mk0iIiIiIgBoSygABc6WWgAA/veff/0PP8bA//LwYAAA\";\n    });\n  }\n\n  static async optimizeImageSrc(originalSrc: string): Promise<string> {\n    const webpSupported = await this.checkWebPSupport();\n\n    if (webpSupported && !originalSrc.includes(\".webp\")) {\n      // Try to get WebP version\n      const webpSrc = originalSrc.replace(/\\.(jpg|jpeg|png)$/i, \".webp\");\n\n      // Check if WebP version exists\n      return new Promise((resolve) => {\n        const img = new Image();\n        img.onload = () => resolve(webpSrc);\n        img.onerror = () => resolve(originalSrc);\n        img.src = webpSrc;\n      });\n    }\n\n    return originalSrc;\n  }\n}\n\n/**\n * Responsive image sizes calculator\n */\nexport class ResponsiveImageSizes {\n  static calculateSizes(breakpoints: Record<string, number> = {}): string {\n    const defaultBreakpoints = {\n      sm: 640,\n      md: 768,\n      lg: 1024,\n      xl: 1280,\n      ...breakpoints,\n    };\n\n    const sizes = [];\n\n    // Mobile first approach\n    sizes.push(\"100vw\");\n\n    // Add breakpoint-specific sizes\n    Object.entries(defaultBreakpoints)\n      .sort(([, a], [, b]) => a - b)\n      .forEach(([name, width]) => {\n        if (name === \"sm\") {\n          sizes.unshift(\"(max-width: 640px) 100vw\");\n        } else if (name === \"md\") {\n          sizes.unshift(\"(max-width: 768px) 50vw\");\n        } else if (name === \"lg\") {\n          sizes.unshift(\"(max-width: 1024px) 33vw\");\n        } else {\n          sizes.unshift(`(max-width: ${width}px) 25vw`);\n        }\n      });\n\n    return sizes.join(\", \");\n  }\n\n  static generateSrcSet(\n    baseSrc: string,\n    widths: number[] = [320, 640, 768, 1024, 1280, 1920]\n  ): string {\n    return widths\n      .map((width) => {\n        const src = baseSrc.replace(/(\\.[^.]+)$/, `_${width}w$1`);\n        return `${src} ${width}w`;\n      })\n      .join(\", \");\n  }\n}\n\n/**\n * Image performance monitoring\n */\nexport class ImagePerformanceMonitor {\n  private static measurements: Map<string, number> = new Map();\n\n  static startMeasurement(imageId: string): void {\n    this.measurements.set(imageId, performance.now());\n  }\n\n  static endMeasurement(imageId: string): number {\n    const startTime = this.measurements.get(imageId);\n    if (!startTime) return 0;\n\n    const endTime = performance.now();\n    const duration = endTime - startTime;\n\n    this.measurements.delete(imageId);\n    return duration;\n  }\n\n  static measureImageLoad(img: HTMLImageElement): Promise<number> {\n    return new Promise((resolve) => {\n      const startTime = performance.now();\n\n      const onLoad = () => {\n        const duration = performance.now() - startTime;\n        img.removeEventListener(\"load\", onLoad);\n        img.removeEventListener(\"error\", onError);\n        resolve(duration);\n      };\n\n      const onError = () => {\n        const duration = performance.now() - startTime;\n        img.removeEventListener(\"load\", onLoad);\n        img.removeEventListener(\"error\", onError);\n        resolve(duration);\n      };\n\n      if (img.complete) {\n        resolve(0);\n      } else {\n        img.addEventListener(\"load\", onLoad);\n        img.addEventListener(\"error\", onError);\n      }\n    });\n  }\n}\n\n// Initialize image optimization when DOM is ready\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n  const imageOptimizer = new ImageOptimization();\n\n  // Re-observe images when new content is added dynamically\n  const observer = new MutationObserver(() => {\n    imageOptimizer.refresh();\n  });\n\n  observer.observe(document.body, {\n    childList: true,\n    subtree: true,\n  });\n});\n\n// Export for use in other modules\nexport { ImageOptimization as default };\n"],"names":["ImageOptimization","constructor","config","observer","this","rootMargin","threshold","loadingClass","loadedClass","errorClass","init","window","IntersectionObserver","entries","forEach","entry","isIntersecting","loadImage","target","unobserve","observeImages","loadAllImages","document","querySelectorAll","img","observe","src","dataset","classList","add","imageLoader","Image","onload","remove","onerror","console","warn","refresh","destroy","disconnect","Map","addEventListener","imageOptimizer","MutationObserver","body","childList","subtree"],"sourceRoot":""}