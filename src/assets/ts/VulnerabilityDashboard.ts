/**
 * Class-based Vulnerability Dashboard for testing
 */

import type {
  Vulnerability,
  VulnerabilityResponse,
  SeverityLevel,
  ExploitationStatus,
  DashboardConfig,
} from "./types";
import Fuse from "fuse.js";

export class VulnerabilityDashboard {
  vulnerabilities: Vulnerability[] = [];
  filteredVulnerabilities: Vulnerability[] = [];
  currentPage = 1;
  pageSize: number;
  sortField: keyof Vulnerability = "riskScore";
  sortDirection: "asc" | "desc" = "desc";
  private fuse: Fuse<Vulnerability> | null = null;
  private filters = {
    search: "",
    severity: "" as SeverityLevel | "",
    cvssMin: 0,
    cvssMax: 10,
    epssMin: 0,
    epssMax: 100,
    dateStart: "",
    dateEnd: "",
    vendor: "",
    exploitStatus: "" as ExploitationStatus | "",
    tags: [] as string[],
  };

  constructor(private config: DashboardConfig) {
    this.pageSize = config.defaultPageSize || 20;
  }

  async loadVulnerabilities(): Promise<void> {
    const response = await fetch(this.config.apiEndpoint);
    if (!response.ok) {
      throw new Error("Failed to load vulnerabilities");
    }
    const data: VulnerabilityResponse = await response.json();
    this.vulnerabilities = data.vulnerabilities;
    this.filteredVulnerabilities = [...this.vulnerabilities];

    // Initialize Fuse for search
    this.fuse = new Fuse(this.vulnerabilities, {
      keys: this.config.searchKeys ?? ["cveId", "title", "description"],
      threshold: 0.3,
    });
  }

  updateFilter<K extends keyof typeof this.filters>(key: K, value: (typeof this.filters)[K]): void {
    this.filters[key] = value;
  }

  getFilters() {
    return { ...this.filters };
  }

  applyFilters(): void {
    // Reinitialize Fuse if needed
    if (!this.fuse && this.vulnerabilities.length > 0) {
      this.fuse = new Fuse(this.vulnerabilities, {
        keys: this.config.searchKeys ?? ["cveId", "title", "description"],
        threshold: 0.3,
      });
    }

    let results = [...this.vulnerabilities];

    // Apply search
    if (this.filters.search.trim() && this.fuse) {
      const searchResults = this.fuse.search(this.filters.search);
      results = searchResults.map((result: { item: Vulnerability }) => result.item);
    }

    // Apply severity filter
    if (this.filters.severity) {
      results = results.filter((v) => v.severity === this.filters.severity);
    }

    // Apply CVSS range
    results = results.filter((v) => {
      if (v.cvssScore === undefined) return true; // Allow missing scores
      return v.cvssScore >= this.filters.cvssMin && v.cvssScore <= this.filters.cvssMax;
    });

    // Apply EPSS range
    results = results.filter((v) => {
      if (v.epssScore === undefined) return true; // Allow missing scores
      return v.epssScore >= this.filters.epssMin && v.epssScore <= this.filters.epssMax;
    });

    // Apply exploitation status
    if (this.filters.exploitStatus) {
      results = results.filter((v) => v.exploitationStatus === this.filters.exploitStatus);
    }

    // Apply vendor filter
    if (this.filters.vendor) {
      results = results.filter((v) => v.vendors?.includes(this.filters.vendor) ?? false);
    }

    // Apply tags filter
    if (this.filters.tags.length > 0) {
      results = results.filter((v) =>
        this.filters.tags.some((tag) => v.tags?.includes(tag) ?? false)
      );
    }

    this.filteredVulnerabilities = results;
    this.currentPage = 1; // Reset to first page
  }

  resetFilters(): void {
    this.filters = {
      search: "",
      severity: "",
      cvssMin: 0,
      cvssMax: 10,
      epssMin: 0,
      epssMax: 100,
      dateStart: "",
      dateEnd: "",
      vendor: "",
      exploitStatus: "",
      tags: [],
    };
  }

  sort(field: keyof Vulnerability, direction?: "asc" | "desc"): void {
    if (field === this.sortField && !direction) {
      this.sortDirection = this.sortDirection === "asc" ? "desc" : "asc";
    } else {
      this.sortField = field;
      this.sortDirection = direction ?? "desc";
    }

    const severityOrder = this.config.severityOrder;

    this.filteredVulnerabilities.sort((a, b) => {
      let aVal: string | number = a[field] as string | number;
      let bVal: string | number = b[field] as string | number;

      // Handle special cases
      if (field === "severity") {
        // Reverse the index for severity so CRITICAL (0) sorts before LOW (3)
        aVal = -severityOrder.indexOf(aVal as string);
        bVal = -severityOrder.indexOf(bVal as string);
      } else if (field === "publishedDate" || field === "lastModifiedDate") {
        aVal = new Date(aVal as string).getTime();
        bVal = new Date(bVal as string).getTime();
      }

      if (aVal < bVal) return this.sortDirection === "asc" ? -1 : 1;
      if (aVal > bVal) return this.sortDirection === "asc" ? 1 : -1;
      return 0;
    });
  }

  getTotalPages(): number {
    return Math.max(1, Math.ceil(this.filteredVulnerabilities.length / this.pageSize));
  }

  getCurrentPageItems(): Vulnerability[] {
    const start = (this.currentPage - 1) * this.pageSize;
    const end = start + this.pageSize;
    return this.filteredVulnerabilities.slice(start, end);
  }

  nextPage(): void {
    if (this.currentPage < this.getTotalPages()) {
      this.currentPage++;
    }
  }

  previousPage(): void {
    if (this.currentPage > 1) {
      this.currentPage--;
    }
  }

  updateURLHash(): void {
    const params = new URLSearchParams();

    if (this.filters.search) params.set("q", this.filters.search);
    if (this.filters.severity) params.set("severity", this.filters.severity);
    if (this.filters.cvssMin > 0) params.set("cvssMin", this.filters.cvssMin.toString());
    if (this.filters.cvssMax < 10) params.set("cvssMax", this.filters.cvssMax.toString());
    if (this.filters.epssMin > 0) params.set("epssMin", this.filters.epssMin.toString());
    if (this.filters.epssMax < 100) params.set("epssMax", this.filters.epssMax.toString());
    if (this.filters.vendor) params.set("vendor", this.filters.vendor);
    if (this.filters.exploitStatus) params.set("exploitStatus", this.filters.exploitStatus);
    if (this.filters.tags.length > 0) params.set("tags", this.filters.tags.join(","));
    if (this.currentPage > 1) params.set("page", this.currentPage.toString());

    window.location.hash = params.toString();
  }

  loadFromURLHash(): void {
    const hash = window.location.hash.slice(1);
    if (!hash) return;

    const params = new URLSearchParams(hash);

    if (params.has("q")) this.filters.search = params.get("q") ?? "";
    if (params.has("severity")) this.filters.severity = params.get("severity") as SeverityLevel;
    if (params.has("cvssMin")) this.filters.cvssMin = parseFloat(params.get("cvssMin") ?? "0") || 0;
    if (params.has("cvssMax"))
      this.filters.cvssMax = parseFloat(params.get("cvssMax") ?? "10") || 10;
    if (params.has("epssMin")) this.filters.epssMin = parseFloat(params.get("epssMin") ?? "0") || 0;
    if (params.has("epssMax"))
      this.filters.epssMax = parseFloat(params.get("epssMax") ?? "100") || 100;
    if (params.has("vendor")) this.filters.vendor = params.get("vendor") ?? "";
    if (params.has("exploitStatus"))
      this.filters.exploitStatus = params.get("exploitStatus") as ExploitationStatus;
    if (params.has("tags"))
      this.filters.tags = (params.get("tags") ?? "").split(",").filter(Boolean);
    if (params.has("page")) this.currentPage = parseInt(params.get("page") ?? "1", 10) || 1;
  }

  exportCSV(): string {
    const headers = [
      "CVE ID",
      "Title",
      "Severity",
      "CVSS Score",
      "EPSS %",
      "Risk Score",
      "Published Date",
      "Vendors",
      "Tags",
    ];

    const rows = this.filteredVulnerabilities.map((v) => [
      v.cveId,
      this.escapeCSV(v.title),
      v.severity,
      v.cvssScore.toFixed(1),
      v.epssScore.toFixed(1),
      v.riskScore,
      new Date(v.publishedDate).toISOString().split("T")[0],
      this.escapeCSV(v.vendors.join(", ")),
      this.escapeCSV(v.tags.join(", ")),
    ]);

    return [headers, ...rows].map((row) => row.join(",")).join("\n");
  }

  private escapeCSV(value: string): string {
    if (value.includes(",") || value.includes('"') || value.includes("\n")) {
      return `"${value.replace(/"/g, '""')}"`;
    }
    return value;
  }

  getStatistics() {
    const vulns = this.filteredVulnerabilities;

    const severityDistribution = {
      CRITICAL: 0,
      HIGH: 0,
      MEDIUM: 0,
      LOW: 0,
    };

    const exploitationCounts = {
      ACTIVE: 0,
      POC: 0,
      NONE: 0,
    };

    const vendorCounts: Record<string, number> = {};
    const tagCounts: Record<string, number> = {};

    let totalCVSS = 0;
    let totalEPSS = 0;
    let totalRisk = 0;

    vulns.forEach((v) => {
      // Severity
      if (v.severity in severityDistribution) {
        severityDistribution[v.severity as keyof typeof severityDistribution]++;
      }

      // Exploitation
      if (v.exploitationStatus in exploitationCounts) {
        exploitationCounts[v.exploitationStatus as keyof typeof exploitationCounts]++;
      }

      // Vendors
      v.vendors.forEach((vendor) => {
        vendorCounts[vendor] = (vendorCounts[vendor] ?? 0) + 1;
      });

      // Tags
      v.tags.forEach((tag) => {
        tagCounts[tag] = (tagCounts[tag] ?? 0) + 1;
      });

      // Scores
      totalCVSS += v.cvssScore;
      totalEPSS += v.epssScore;
      totalRisk += v.riskScore;
    });

    const count = vulns.length || 1;

    return {
      severityDistribution,
      exploitationCounts,
      averageCVSS: totalCVSS / count,
      averageEPSS: totalEPSS / count,
      averageRiskScore: totalRisk / count,
      topVendors: Object.entries(vendorCounts)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 10)
        .map(([vendor, count]) => ({ vendor, count })),
      topTags: Object.entries(tagCounts)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 10)
        .map(([tag, count]) => ({ tag, count })),
    };
  }
}
